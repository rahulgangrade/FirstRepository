import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

public class MissingStatusFinder {

    // Regex to extract uppercase tokens with underscores or digits, e.g. PRE_VALIDATION_FAILURE, ERROR_1
    private static final Pattern CAPS_TOKEN_PATTERN = Pattern.compile("\\b[A-Z][A-Z0-9_]+\\b");

    /**
     * Extracts CAPS tokens from possibleValidations and returns missing ones (not found in scenarioInfo).
     * Returned as newline-separated String (empty string if none).
     *
     * Uses StringBuilder to build the final string (one token per line).
     */
    public static String findMissingStatuses(String possibleValidations, String scenarioInfo) {
        if (possibleValidations == null || possibleValidations.trim().isEmpty()) {
            return "";
        }
        if (scenarioInfo == null) {
            scenarioInfo = "";
        }

        // Use a LinkedHashSet to preserve order and remove duplicates
        Set<String> expectedTokens = new LinkedHashSet<>();
        Matcher m = CAPS_TOKEN_PATTERN.matcher(possibleValidations);
        while (m.find()) {
            expectedTokens.add(m.group());
        }

        if (expectedTokens.isEmpty()) {
            return "";
        }

        StringBuilder missing = new StringBuilder();
        for (String token : expectedTokens) {
            // Build regex to check whole-token presence in scenarioInfo
            Pattern tokenPattern = Pattern.compile("\\b" + Pattern.quote(token) + "\\b");
            Matcher actualMatcher = tokenPattern.matcher(scenarioInfo);

            if (!actualMatcher.find()) {
                if (missing.length() > 0) {
                    // newline separator for Excel cell (will show as new line when wrapText is true)
                    missing.append("\n");
                }
                missing.append(token);
            }
        }

        return missing.toString();
    }

    /**
     * Reads an input Excel file and writes missing statuses to the 3rd column (one-per-line in cell).
     * Adjust INPUT_FILE, OUTPUT_FILE, sheet name, and column indices as needed.
     */
    public static void processExcel(String inputFilePath, String outputFilePath) throws IOException {
        // Column indexes (0-based)
        int expectedColIndex = 0; // POSSIBLE_VALIDATIONS column - A
        int actualColIndex   = 1; // SCENARIO_INFO column - B
        int resultColIndex   = 2; // MISSING_STATUS column - C (will be written)

        try (FileInputStream fis = new FileInputStream(inputFilePath);
             Workbook workbook = new XSSFWorkbook(fis)) {

            Sheet sheet = workbook.getSheetAt(0); // or workbook.getSheet("Sheet1");
            if (sheet == null) {
                throw new IllegalArgumentException("Sheet not found in workbook");
            }

            // Create a reusable cell style for wrapped text
            CellStyle wrapStyle = workbook.createCellStyle();
            wrapStyle.setWrapText(true);

            // Optionally set a font or vertical alignment if you prefer
            wrapStyle.setVerticalAlignment(VerticalAlignment.TOP);

            // Assuming first row is header; start from row 1
            int firstDataRow = sheet.getFirstRowNum() + 1;
            int lastRow = sheet.getLastRowNum();

            // default row height in points (used to compute new height)
            float defaultRowHeightPoints = sheet.getDefaultRowHeightInPoints();

            for (int r = firstDataRow; r <= lastRow; r++) {
                Row row = sheet.getRow(r);
                if (row == null) continue;

                Cell expectedCell = row.getCell(expectedColIndex, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL);
                Cell actualCell   = row.getCell(actualColIndex, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);

                String expected = expectedCell != null ? getCellStringValue(expectedCell) : "";
                String actual   = actualCell != null ? getCellStringValue(actualCell) : "";

                String missing = findMissingStatuses(expected, actual);

                // Write to result column
                Cell resultCell = row.getCell(resultColIndex, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);
                resultCell.setCellStyle(wrapStyle);
                resultCell.setCellValue(missing);

                // Adjust row height if we have multiple lines so the wrapped text is visible.
                if (missing != null && !missing.isEmpty()) {
                    int lines = countLines(missing);
                    // small multiplier to provide spacing; adjust 1.2f as needed
                    float newHeight = Math.max(defaultRowHeightPoints, lines * defaultRowHeightPoints * 1.2f);
                    row.setHeightInPoints(newHeight);
                }
            }

            // Optionally autosize the result column so that width fits (note: autosize is expensive on large sheets)
            sheet.autoSizeColumn(resultColIndex);

            // Write out to new file (or overwrite)
            try (FileOutputStream fos = new FileOutputStream(outputFilePath)) {
                workbook.write(fos);
            }
        }
    }

    private static int countLines(String s) {
        if (s == null || s.isEmpty()) return 0;
        // Count occurrences of '\n' + 1
        int lines = 1;
        int idx = 0;
        while ((idx = s.indexOf('\n', idx)) != -1) {
            lines++;
            idx++; // move past found char
        }
        return lines;
    }

    private static String getCellStringValue(Cell cell) {
        if (cell == null) return "";
        switch (cell.getCellType()) {
            case STRING: return cell.getStringCellValue();
            case NUMERIC: return String.valueOf(cell.getNumericCellValue());
            case BOOLEAN: return String.valueOf(cel
